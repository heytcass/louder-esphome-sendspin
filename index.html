<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Room Correction - Louder ESP32</title>
    <style>
        :root {
            --bg: #1a1a2e;
            --surface: #16213e;
            --primary: #0f3460;
            --accent: #e94560;
            --text: #eee;
            --text-dim: #888;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 600px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }
        
        .subtitle {
            text-align: center;
            color: var(--text-dim);
            margin-bottom: 30px;
            font-size: 0.9rem;
        }
        
        .card {
            background: var(--surface);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .card h2 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .step-number {
            background: var(--accent);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            width: 100%;
            transition: all 0.2s;
        }
        
        button:hover:not(:disabled) {
            background: var(--accent);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.secondary {
            background: transparent;
            border: 2px solid var(--primary);
        }
        
        .status {
            text-align: center;
            padding: 10px;
            margin-top: 15px;
            border-radius: 6px;
            font-size: 0.9rem;
        }
        
        .status.info { background: rgba(15, 52, 96, 0.5); }
        .status.success { background: rgba(46, 204, 113, 0.3); }
        .status.error { background: rgba(233, 69, 96, 0.3); }
        
        canvas {
            width: 100%;
            height: 200px;
            background: var(--bg);
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .filter-list {
            margin-top: 15px;
        }
        
        .filter-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: var(--bg);
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }
        
        .filter-item .freq { color: var(--accent); font-weight: bold; }
        .filter-item .gain { color: #2ecc71; }
        .filter-item .q { color: var(--text-dim); }
        
        .progress-bar {
            height: 4px;
            background: var(--bg);
            border-radius: 2px;
            margin-top: 15px;
            overflow: hidden;
        }
        
        .progress-bar .fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s;
        }
        
        .ha-config {
            display: grid;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        input {
            background: var(--bg);
            border: 1px solid var(--primary);
            color: var(--text);
            padding: 12px;
            border-radius: 6px;
            font-size: 1rem;
        }
        
        input::placeholder {
            color: var(--text-dim);
        }
        
        .instructions {
            font-size: 0.85rem;
            color: var(--text-dim);
            line-height: 1.6;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”Š Room Correction</h1>
        <p class="subtitle">Louder ESP32-S3 + TAS5805M DSP</p>
        
        <!-- Step 1: Connection -->
        <div class="card">
            <h2><span class="step-number">1</span> Connect</h2>
            <div class="ha-config">
                <input type="text" id="ha-url" placeholder="Home Assistant URL (e.g., http://homeassistant.local:8123)">
                <input type="password" id="ha-token" placeholder="Long-lived access token">
                <input type="text" id="device-name" placeholder="ESPHome device name (e.g., louder-s3-kitchen)">
            </div>
            <button id="btn-connect">Connect to Home Assistant</button>
            <div id="connect-status" class="status info" style="display:none;"></div>
        </div>
        
        <!-- Step 2: Measurement -->
        <div class="card">
            <h2><span class="step-number">2</span> Measure</h2>
            <ol class="instructions">
                <li>Hold your phone at your normal listening position</li>
                <li>Keep the room quiet during measurement</li>
                <li>The speaker will play a 5-second frequency sweep</li>
            </ol>
            <button id="btn-measure" disabled>Start Measurement</button>
            <div class="progress-bar"><div class="fill" id="measure-progress"></div></div>
            <canvas id="response-chart"></canvas>
            <div id="measure-status" class="status info" style="display:none;"></div>
        </div>
        
        <!-- Step 3: Calculate -->
        <div class="card">
            <h2><span class="step-number">3</span> Calculate Filters</h2>
            <p class="instructions">
                Analyzes room response and generates correction filters.
                Focus is on bass (20-200Hz) where room modes cause the most issues.
            </p>
            <button id="btn-calculate" disabled>Calculate Corrections</button>
            <div class="filter-list" id="filter-list"></div>
        </div>
        
        <!-- Step 4: Apply -->
        <div class="card">
            <h2><span class="step-number">4</span> Apply to DSP</h2>
            <button id="btn-apply" disabled>Apply Filters to TAS5805M</button>
            <button id="btn-reset" class="secondary" style="margin-top:10px;" disabled>Reset to Flat</button>
            <div id="apply-status" class="status info" style="display:none;"></div>
        </div>
    </div>

    <script>
    // =============================================================================
    // ROOM CORRECTION CALIBRATION APP
    // =============================================================================
    
    const state = {
        haUrl: '',
        haToken: '',
        deviceName: '',
        connected: false,
        audioContext: null,
        measuredResponse: null,
        calculatedFilters: [],
    };
    
    // =============================================================================
    // HOME ASSISTANT API
    // =============================================================================
    
    async function callHaService(domain, service, data = {}) {
        const response = await fetch(`${state.haUrl}/api/services/${domain}/${service}`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${state.haToken}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
        });
        
        if (!response.ok) {
            throw new Error(`HA API error: ${response.status}`);
        }
        
        return response.json();
    }
    
    async function testConnection() {
        const response = await fetch(`${state.haUrl}/api/`, {
            headers: { 'Authorization': `Bearer ${state.haToken}` },
        });
        return response.ok;
    }
    
    // =============================================================================
    // AUDIO MEASUREMENT
    // =============================================================================
    
    async function initAudio() {
        if (state.audioContext) return;
        
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: 48000,
        });
        
        // Request microphone access
        const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false,
            }
        });
        
        state.micSource = state.audioContext.createMediaStreamSource(stream);
        state.analyser = state.audioContext.createAnalyser();
        state.analyser.fftSize = 8192;
        state.analyser.smoothingTimeConstant = 0.3;
        
        state.micSource.connect(state.analyser);
    }
    
    function generateSweep(startFreq, endFreq, duration, sampleRate) {
        const numSamples = Math.floor(duration * sampleRate);
        const buffer = new Float32Array(numSamples);
        
        // Logarithmic sweep
        const k = Math.log(endFreq / startFreq);
        
        for (let i = 0; i < numSamples; i++) {
            const t = i / sampleRate;
            const phase = 2 * Math.PI * startFreq * duration / k * 
                         (Math.exp(k * t / duration) - 1);
            buffer[i] = Math.sin(phase) * 0.8;  // 80% amplitude
        }
        
        return buffer;
    }
    
    async function measureRoom() {
        await initAudio();
        
        const fftSize = state.analyser.fftSize;
        const binCount = state.analyser.frequencyBinCount;
        const sampleRate = state.audioContext.sampleRate;
        
        // Generate sweep (played by ESP32, we just capture)
        // For now, we'll use the browser to play the sweep for testing
        const sweepDuration = 5;
        const sweepBuffer = generateSweep(20, 20000, sweepDuration, sampleRate);
        
        // Create audio buffer and play
        const audioBuffer = state.audioContext.createBuffer(1, sweepBuffer.length, sampleRate);
        audioBuffer.getChannelData(0).set(sweepBuffer);
        
        const source = state.audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(state.audioContext.destination);
        
        // Accumulate FFT data during sweep
        const measurements = [];
        const measurementInterval = 50;  // ms
        const numMeasurements = Math.floor(sweepDuration * 1000 / measurementInterval);
        
        return new Promise((resolve) => {
            source.start();
            
            let count = 0;
            const interval = setInterval(() => {
                const freqData = new Float32Array(binCount);
                state.analyser.getFloatFrequencyData(freqData);
                measurements.push([...freqData]);
                
                count++;
                document.getElementById('measure-progress').style.width = 
                    `${(count / numMeasurements) * 100}%`;
                
                if (count >= numMeasurements) {
                    clearInterval(interval);
                    
                    // Average all measurements
                    const avgResponse = new Float32Array(binCount);
                    for (let i = 0; i < binCount; i++) {
                        let sum = 0;
                        for (const m of measurements) {
                            sum += m[i];
                        }
                        avgResponse[i] = sum / measurements.length;
                    }
                    
                    state.measuredResponse = {
                        frequencies: Array.from({length: binCount}, (_, i) => 
                            i * sampleRate / fftSize),
                        magnitudes: avgResponse,
                        sampleRate: sampleRate,
                    };
                    
                    resolve(state.measuredResponse);
                }
            }, measurementInterval);
        });
    }
    
    function drawResponse(response) {
        const canvas = document.getElementById('response-chart');
        const ctx = canvas.getContext('2d');
        
        // Set actual canvas resolution
        canvas.width = canvas.offsetWidth * 2;
        canvas.height = canvas.offsetHeight * 2;
        ctx.scale(2, 2);
        
        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;
        
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, width, height);
        
        // Draw grid
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 0.5;
        
        // Frequency grid (log scale)
        const freqs = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
        ctx.fillStyle = '#666';
        ctx.font = '10px sans-serif';
        
        for (const f of freqs) {
            const x = freqToX(f, width);
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
            ctx.fillText(f >= 1000 ? `${f/1000}k` : f, x + 2, height - 5);
        }
        
        // dB grid
        for (let db = -60; db <= 0; db += 10) {
            const y = dbToY(db, height);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
            ctx.fillText(`${db}dB`, 5, y - 2);
        }
        
        // Draw response curve
        ctx.strokeStyle = '#e94560';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        let started = false;
        for (let i = 0; i < response.frequencies.length; i++) {
            const freq = response.frequencies[i];
            if (freq < 20 || freq > 20000) continue;
            
            const x = freqToX(freq, width);
            const y = dbToY(response.magnitudes[i], height);
            
            if (!started) {
                ctx.moveTo(x, y);
                started = true;
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();
        
        // Draw target curve (slight downward slope)
        ctx.strokeStyle = '#2ecc71';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(freqToX(20, width), dbToY(-30, height));
        ctx.lineTo(freqToX(20000, width), dbToY(-40, height));
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    function freqToX(freq, width) {
        const minLog = Math.log10(20);
        const maxLog = Math.log10(20000);
        return ((Math.log10(freq) - minLog) / (maxLog - minLog)) * width;
    }
    
    function dbToY(db, height) {
        const minDb = -80;
        const maxDb = 0;
        return height - ((db - minDb) / (maxDb - minDb)) * height;
    }
    
    // =============================================================================
    // FILTER CALCULATION
    // =============================================================================
    
    function calculateFilters(response) {
        const filters = [];
        const sampleRate = response.sampleRate;
        
        // Smooth the response (1/6 octave)
        const smoothed = smoothResponse(response.frequencies, response.magnitudes, 1/6);
        
        // Calculate target curve (slight downward slope)
        const target = response.frequencies.map(f => {
            if (f < 20) return -100;
            // -0.5dB per octave slope from 100Hz reference
            return -35 - 0.5 * Math.log2(f / 100);
        });
        
        // Find peaks that need correction (focus on bass)
        const deviations = [];
        for (let i = 0; i < smoothed.length; i++) {
            const freq = response.frequencies[i];
            if (freq < 25 || freq > 500) continue;  // Focus on bass
            
            const deviation = smoothed[i] - target[i];
            if (deviation > 3) {  // Only correct peaks > 3dB
                deviations.push({
                    frequency: freq,
                    deviation: deviation,
                    index: i,
                });
            }
        }
        
        // Sort by deviation magnitude and take top 8
        deviations.sort((a, b) => b.deviation - a.deviation);
        const peaksToCorrect = deviations.slice(0, 8);
        
        // Generate parametric EQ filters
        for (const peak of peaksToCorrect) {
            // Calculate Q based on peak width (estimate)
            const q = estimateQ(response.frequencies, smoothed, peak.index);
            
            // Limit correction to -12dB max
            const gain = Math.max(-12, -peak.deviation);
            
            const coeffs = calculateParametricEQ(peak.frequency, gain, q, sampleRate);
            
            filters.push({
                type: 'parametric',
                frequency: Math.round(peak.frequency),
                gain: Math.round(gain * 10) / 10,
                q: Math.round(q * 100) / 100,
                coefficients: coeffs,
            });
        }
        
        // Add subsonic high-pass at 25Hz for speaker protection
        const hpCoeffs = calculateHighPass(25, 0.707, sampleRate);
        filters.unshift({
            type: 'highpass',
            frequency: 25,
            gain: 0,
            q: 0.707,
            coefficients: hpCoeffs,
        });
        
        return filters;
    }
    
    function smoothResponse(frequencies, magnitudes, octaveFraction) {
        const smoothed = new Float32Array(magnitudes.length);
        
        for (let i = 0; i < magnitudes.length; i++) {
            const centerFreq = frequencies[i];
            if (centerFreq <= 0) {
                smoothed[i] = magnitudes[i];
                continue;
            }
            
            const lowFreq = centerFreq / Math.pow(2, octaveFraction / 2);
            const highFreq = centerFreq * Math.pow(2, octaveFraction / 2);
            
            let sum = 0;
            let count = 0;
            
            for (let j = 0; j < magnitudes.length; j++) {
                if (frequencies[j] >= lowFreq && frequencies[j] <= highFreq) {
                    sum += magnitudes[j];
                    count++;
                }
            }
            
            smoothed[i] = count > 0 ? sum / count : magnitudes[i];
        }
        
        return smoothed;
    }
    
    function estimateQ(frequencies, magnitudes, peakIndex) {
        // Find -3dB points around peak
        const peakLevel = magnitudes[peakIndex];
        const targetLevel = peakLevel - 3;
        
        let lowIndex = peakIndex;
        let highIndex = peakIndex;
        
        while (lowIndex > 0 && magnitudes[lowIndex] > targetLevel) lowIndex--;
        while (highIndex < magnitudes.length - 1 && magnitudes[highIndex] > targetLevel) highIndex++;
        
        const lowFreq = frequencies[lowIndex];
        const highFreq = frequencies[highIndex];
        const centerFreq = frequencies[peakIndex];
        
        if (highFreq <= lowFreq) return 2;  // Default Q
        
        const bandwidth = highFreq - lowFreq;
        const q = centerFreq / bandwidth;
        
        // Clamp Q to reasonable range
        return Math.max(0.5, Math.min(10, q));
    }
    
    // =============================================================================
    // BIQUAD COEFFICIENT CALCULATION
    // =============================================================================
    
    function calculateParametricEQ(fc, gainDb, q, fs) {
        const A = Math.pow(10, gainDb / 40);
        const omega = 2 * Math.PI * fc / fs;
        const sinOmega = Math.sin(omega);
        const cosOmega = Math.cos(omega);
        const alpha = sinOmega / (2 * q);
        
        let b0 = 1 + alpha * A;
        let b1 = -2 * cosOmega;
        let b2 = 1 - alpha * A;
        let a0 = 1 + alpha / A;
        let a1 = -2 * cosOmega;
        let a2 = 1 - alpha / A;
        
        // Normalize
        b0 /= a0;
        b1 /= a0;
        b2 /= a0;
        a1 /= a0;
        a2 /= a0;
        
        return { b0, b1, b2, a1, a2 };
    }
    
    function calculateHighPass(fc, q, fs) {
        const omega = 2 * Math.PI * fc / fs;
        const sinOmega = Math.sin(omega);
        const cosOmega = Math.cos(omega);
        const alpha = sinOmega / (2 * q);
        
        let b0 = (1 + cosOmega) / 2;
        let b1 = -(1 + cosOmega);
        let b2 = (1 + cosOmega) / 2;
        let a0 = 1 + alpha;
        let a1 = -2 * cosOmega;
        let a2 = 1 - alpha;
        
        b0 /= a0;
        b1 /= a0;
        b2 /= a0;
        a1 /= a0;
        a2 /= a0;
        
        return { b0, b1, b2, a1, a2 };
    }
    
    function calculateLowShelf(fc, gainDb, slope, fs) {
        const A = Math.pow(10, gainDb / 40);
        const omega = 2 * Math.PI * fc / fs;
        const sinOmega = Math.sin(omega);
        const cosOmega = Math.cos(omega);
        const alpha = sinOmega / 2 * Math.sqrt((A + 1/A) * (1/slope - 1) + 2);
        const twoSqrtAAlpha = 2 * Math.sqrt(A) * alpha;
        
        let b0 = A * ((A + 1) - (A - 1) * cosOmega + twoSqrtAAlpha);
        let b1 = 2 * A * ((A - 1) - (A + 1) * cosOmega);
        let b2 = A * ((A + 1) - (A - 1) * cosOmega - twoSqrtAAlpha);
        let a0 = (A + 1) + (A - 1) * cosOmega + twoSqrtAAlpha;
        let a1 = -2 * ((A - 1) + (A + 1) * cosOmega);
        let a2 = (A + 1) + (A - 1) * cosOmega - twoSqrtAAlpha;
        
        b0 /= a0;
        b1 /= a0;
        b2 /= a0;
        a1 /= a0;
        a2 /= a0;
        
        return { b0, b1, b2, a1, a2 };
    }
    
    // =============================================================================
    // UI HANDLERS
    // =============================================================================
    
    document.getElementById('btn-connect').addEventListener('click', async () => {
        const statusEl = document.getElementById('connect-status');
        statusEl.style.display = 'block';
        statusEl.className = 'status info';
        statusEl.textContent = 'Connecting...';
        
        state.haUrl = document.getElementById('ha-url').value.replace(/\/$/, '');
        state.haToken = document.getElementById('ha-token').value;
        state.deviceName = document.getElementById('device-name').value;
        
        try {
            const ok = await testConnection();
            if (ok) {
                state.connected = true;
                statusEl.className = 'status success';
                statusEl.textContent = 'Connected to Home Assistant';
                document.getElementById('btn-measure').disabled = false;
            } else {
                throw new Error('Connection failed');
            }
        } catch (e) {
            statusEl.className = 'status error';
            statusEl.textContent = `Error: ${e.message}`;
        }
    });
    
    document.getElementById('btn-measure').addEventListener('click', async () => {
        const btn = document.getElementById('btn-measure');
        const statusEl = document.getElementById('measure-status');
        
        btn.disabled = true;
        btn.textContent = 'Measuring...';
        statusEl.style.display = 'block';
        statusEl.className = 'status info';
        statusEl.textContent = 'Playing sweep, capturing response...';
        
        try {
            const response = await measureRoom();
            drawResponse(response);
            
            statusEl.className = 'status success';
            statusEl.textContent = 'Measurement complete';
            document.getElementById('btn-calculate').disabled = false;
        } catch (e) {
            statusEl.className = 'status error';
            statusEl.textContent = `Error: ${e.message}`;
        }
        
        btn.disabled = false;
        btn.textContent = 'Start Measurement';
    });
    
    document.getElementById('btn-calculate').addEventListener('click', () => {
        const listEl = document.getElementById('filter-list');
        listEl.innerHTML = '';
        
        state.calculatedFilters = calculateFilters(state.measuredResponse);
        
        for (const filter of state.calculatedFilters) {
            const div = document.createElement('div');
            div.className = 'filter-item';
            
            if (filter.type === 'highpass') {
                div.innerHTML = `
                    <span>High-Pass</span>
                    <span class="freq">${filter.frequency} Hz</span>
                    <span class="q">Q ${filter.q}</span>
                `;
            } else {
                div.innerHTML = `
                    <span>PEQ</span>
                    <span class="freq">${filter.frequency} Hz</span>
                    <span class="gain">${filter.gain > 0 ? '+' : ''}${filter.gain} dB</span>
                    <span class="q">Q ${filter.q}</span>
                `;
            }
            
            listEl.appendChild(div);
        }
        
        document.getElementById('btn-apply').disabled = false;
        document.getElementById('btn-reset').disabled = false;
    });
    
    document.getElementById('btn-apply').addEventListener('click', async () => {
        const btn = document.getElementById('btn-apply');
        const statusEl = document.getElementById('apply-status');
        
        btn.disabled = true;
        statusEl.style.display = 'block';
        statusEl.className = 'status info';
        statusEl.textContent = 'Applying filters to TAS5805M...';
        
        try {
            // Apply each filter via HA service
            for (let i = 0; i < state.calculatedFilters.length; i++) {
                const filter = state.calculatedFilters[i];
                const c = filter.coefficients;
                
                await callHaService('esphome', `${state.deviceName}_set_biquad`, {
                    channel: 2,  // Both channels
                    index: i,
                    b0: c.b0,
                    b1: c.b1,
                    b2: c.b2,
                    a1: c.a1,
                    a2: c.a2,
                });
                
                statusEl.textContent = `Applied filter ${i + 1}/${state.calculatedFilters.length}`;
                await new Promise(r => setTimeout(r, 100));  // Small delay between writes
            }
            
            statusEl.className = 'status success';
            statusEl.textContent = 'All filters applied successfully!';
        } catch (e) {
            statusEl.className = 'status error';
            statusEl.textContent = `Error: ${e.message}`;
        }
        
        btn.disabled = false;
    });
    
    document.getElementById('btn-reset').addEventListener('click', async () => {
        const statusEl = document.getElementById('apply-status');
        statusEl.style.display = 'block';
        statusEl.className = 'status info';
        statusEl.textContent = 'Resetting EQ...';
        
        try {
            await callHaService('esphome', `${state.deviceName}_reset_eq`, {});
            statusEl.className = 'status success';
            statusEl.textContent = 'EQ reset to flat';
        } catch (e) {
            statusEl.className = 'status error';
            statusEl.textContent = `Error: ${e.message}`;
        }
    });
    </script>
</body>
</html>
