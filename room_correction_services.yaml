# =============================================================================
# ROOM CORRECTION SERVICES FOR LOUDER-ESP32S3
# =============================================================================
# Include this in your main config with:
#   packages:
#     room_correction: !include room_correction_services.yaml
#
# Or copy the relevant sections into your main YAML.
#
# Requires:
#   - i2c bus with id: i2c_bus
#   - tas5805m_biquad_i2c.h in the same directory
# =============================================================================

esphome:
  # Note: includes moved to main YAML for correct code generation order
  on_boot:
    priority: -100  # Run after other components initialize
    then:
      - lambda: |-
          // Initialize profile manager and load active profile
          tas5805m_profile::profile_manager().setup();

          // Auto-load active profile if one is set
          tas5805m_profile::profile_manager().load_and_apply_active_profile(id(i2c_bus), id(tas5805m_addr));

# Enable web server for calibration UI
web_server:
  port: 80
  version: 3
  local: true

# Globals for calibration state
globals:
  - id: calibration_active
    type: bool
    initial_value: 'false'

  # TAS5805M I2C address - change if using non-default address
  - id: tas5805m_addr
    type: uint8_t
    initial_value: '0x2C'

  # Note: profile_manager and current_profile_shadow are defined as static
  # globals in tas5805m_profile_manager.h to avoid ESPHome code generation
  # order issues with custom types

# =============================================================================
# HOME ASSISTANT SERVICES
# =============================================================================

api:
  services:
    # =========================================================================
    # Raw biquad programming (for advanced users)
    # =========================================================================
    - service: set_biquad
      variables:
        channel: int      # 0 = left, 1 = right, 2 = both
        index: int        # 0-14 (which of the 15 biquads)
        b0: float
        b1: float
        b2: float
        a1: float
        a2: float
      then:
        - lambda: |-
            // Validate parameters using helper functions
            if (!tas5805m_biquad::validate_channel(channel)) return;
            if (!tas5805m_biquad::validate_index(index)) return;
            if (!tas5805m_biquad::validate_coefficients(b0, b1, b2, a1, a2)) return;

            ESP_LOGI("room_cal", "set_biquad: ch=%d idx=%d", channel, index);
            ESP_LOGI("room_cal", "  b0=%.6f b1=%.6f b2=%.6f a1=%.6f a2=%.6f", b0, b1, b2, a1, a2);

            bool success = tas5805m_biquad::write_biquad(
                id(i2c_bus), id(tas5805m_addr),
                channel, index,
                b0, b1, b2, a1, a2
            );

            if (success) {
                ESP_LOGI("room_cal", "Biquad %d written successfully", index);

                // Update shadow state
                tas5805m_profile::add_filter_to_profile(
                    tas5805m_profile::current_profile_shadow(),
                    channel, index,
                    b0, b1, b2, a1, a2
                );
            } else {
                ESP_LOGE("room_cal", "Failed to write biquad %d", index);
            }

    # =========================================================================
    # Parametric EQ (most common for room correction)
    # =========================================================================
    - service: set_parametric_eq
      variables:
        channel: int      # 0 = left, 1 = right, 2 = both
        index: int        # 0-14
        frequency: float  # Center frequency in Hz (20-20000)
        gain_db: float    # Gain in dB (-15 to +6 recommended)
        q: float          # Q factor (0.5 to 10)
      then:
        - lambda: |-
            // Validate parameters using helper functions
            if (!tas5805m_biquad::validate_channel(channel)) return;
            if (!tas5805m_biquad::validate_index(index)) return;
            if (!tas5805m_biquad::validate_frequency(frequency)) return;
            if (!tas5805m_biquad::validate_gain(gain_db)) return;
            if (!tas5805m_biquad::validate_q(q)) return;

            ESP_LOGI("room_cal", "set_parametric_eq: ch=%d idx=%d fc=%.1fHz gain=%.1fdB Q=%.2f",
                     channel, index, frequency, gain_db, q);

            // Array to receive calculated coefficients
            float coeffs[5];

            bool success = tas5805m_biquad::write_parametric_eq(
                id(i2c_bus), id(tas5805m_addr),
                channel, index,
                frequency, gain_db, q,
                48000.0f, coeffs
            );

            if (success) {
                ESP_LOGI("room_cal", "Parametric EQ written successfully");

                // Update shadow state with calculated coefficients
                tas5805m_profile::add_filter_to_profile(
                    tas5805m_profile::current_profile_shadow(),
                    channel, index,
                    coeffs[0], coeffs[1], coeffs[2], coeffs[3], coeffs[4]
                );
            } else {
                ESP_LOGE("room_cal", "Failed to write parametric EQ");
            }

    # =========================================================================
    # Low shelf filter (bass adjustment)
    # =========================================================================
    - service: set_low_shelf
      variables:
        channel: int
        index: int
        frequency: float  # Corner frequency in Hz
        gain_db: float    # Gain in dB
        slope: float      # Slope (0.5 to 2.0, 1.0 = 6dB/oct)
      then:
        - lambda: |-
            // Validate parameters using helper functions
            if (!tas5805m_biquad::validate_channel(channel)) return;
            if (!tas5805m_biquad::validate_index(index)) return;
            if (!tas5805m_biquad::validate_frequency(frequency)) return;
            if (!tas5805m_biquad::validate_gain(gain_db)) return;
            if (!tas5805m_biquad::validate_slope(slope)) return;

            ESP_LOGI("room_cal", "set_low_shelf: ch=%d idx=%d fc=%.1fHz gain=%.1fdB slope=%.2f",
                     channel, index, frequency, gain_db, slope);

            // Array to receive calculated coefficients
            float coeffs[5];

            bool success = tas5805m_biquad::write_low_shelf(
                id(i2c_bus), id(tas5805m_addr),
                channel, index,
                frequency, gain_db, slope,
                48000.0f, coeffs
            );

            if (success) {
                ESP_LOGI("room_cal", "Low shelf written successfully");

                // Update shadow state with calculated coefficients
                tas5805m_profile::add_filter_to_profile(
                    tas5805m_profile::current_profile_shadow(),
                    channel, index,
                    coeffs[0], coeffs[1], coeffs[2], coeffs[3], coeffs[4]
                );
            } else {
                ESP_LOGE("room_cal", "Failed to write low shelf");
            }

    # =========================================================================
    # High shelf filter (treble adjustment)
    # =========================================================================
    - service: set_high_shelf
      variables:
        channel: int
        index: int
        frequency: float
        gain_db: float
        slope: float
      then:
        - lambda: |-
            // Validate parameters using helper functions
            if (!tas5805m_biquad::validate_channel(channel)) return;
            if (!tas5805m_biquad::validate_index(index)) return;
            if (!tas5805m_biquad::validate_frequency(frequency)) return;
            if (!tas5805m_biquad::validate_gain(gain_db)) return;
            if (!tas5805m_biquad::validate_slope(slope)) return;

            ESP_LOGI("room_cal", "set_high_shelf: ch=%d idx=%d fc=%.1fHz gain=%.1fdB slope=%.2f",
                     channel, index, frequency, gain_db, slope);

            // Array to receive calculated coefficients
            float coeffs[5];

            bool success = tas5805m_biquad::write_high_shelf(
                id(i2c_bus), id(tas5805m_addr),
                channel, index,
                frequency, gain_db, slope,
                48000.0f, coeffs
            );

            if (success) {
                ESP_LOGI("room_cal", "High shelf written successfully");

                // Update shadow state with calculated coefficients
                tas5805m_profile::add_filter_to_profile(
                    tas5805m_profile::current_profile_shadow(),
                    channel, index,
                    coeffs[0], coeffs[1], coeffs[2], coeffs[3], coeffs[4]
                );
            } else {
                ESP_LOGE("room_cal", "Failed to write high shelf");
            }

    # =========================================================================
    # High-pass filter (subsonic protection)
    # =========================================================================
    - service: set_highpass
      variables:
        channel: int
        index: int
        frequency: float  # Cutoff frequency in Hz
        q: float          # Q factor (0.707 = Butterworth)
      then:
        - lambda: |-
            // Validate parameters using helper functions
            if (!tas5805m_biquad::validate_channel(channel)) return;
            if (!tas5805m_biquad::validate_index(index)) return;
            if (!tas5805m_biquad::validate_frequency(frequency, 5.0f, 24000.0f)) return;
            if (!tas5805m_biquad::validate_q(q)) return;

            ESP_LOGI("room_cal", "set_highpass: ch=%d idx=%d fc=%.1fHz Q=%.2f",
                     channel, index, frequency, q);

            // Array to receive calculated coefficients
            float coeffs[5];

            bool success = tas5805m_biquad::write_highpass(
                id(i2c_bus), id(tas5805m_addr),
                channel, index,
                frequency, q,
                48000.0f, coeffs
            );

            if (success) {
                ESP_LOGI("room_cal", "High-pass written successfully");

                // Update shadow state with calculated coefficients
                tas5805m_profile::add_filter_to_profile(
                    tas5805m_profile::current_profile_shadow(),
                    channel, index,
                    coeffs[0], coeffs[1], coeffs[2], coeffs[3], coeffs[4]
                );
            } else {
                ESP_LOGE("room_cal", "Failed to write high-pass");
            }

    # =========================================================================
    # Low-pass filter (tweeter protection)
    # =========================================================================
    - service: set_lowpass
      variables:
        channel: int
        index: int
        frequency: float
        q: float
      then:
        - lambda: |-
            // Validate parameters using helper functions
            if (!tas5805m_biquad::validate_channel(channel)) return;
            if (!tas5805m_biquad::validate_index(index)) return;
            if (!tas5805m_biquad::validate_frequency(frequency)) return;
            if (!tas5805m_biquad::validate_q(q)) return;

            ESP_LOGI("room_cal", "set_lowpass: ch=%d idx=%d fc=%.1fHz Q=%.2f",
                     channel, index, frequency, q);

            // Array to receive calculated coefficients
            float coeffs[5];

            bool success = tas5805m_biquad::write_lowpass(
                id(i2c_bus), id(tas5805m_addr),
                channel, index,
                frequency, q,
                48000.0f, coeffs
            );

            if (success) {
                ESP_LOGI("room_cal", "Low-pass written successfully");

                // Update shadow state with calculated coefficients
                tas5805m_profile::add_filter_to_profile(
                    tas5805m_profile::current_profile_shadow(),
                    channel, index,
                    coeffs[0], coeffs[1], coeffs[2], coeffs[3], coeffs[4]
                );
            } else {
                ESP_LOGE("room_cal", "Failed to write low-pass");
            }

    # =========================================================================
    # Notch filter (kill specific resonance)
    # =========================================================================
    - service: set_notch
      variables:
        channel: int
        index: int
        frequency: float
        q: float
      then:
        - lambda: |-
            // Validate parameters using helper functions
            if (!tas5805m_biquad::validate_channel(channel)) return;
            if (!tas5805m_biquad::validate_index(index)) return;
            if (!tas5805m_biquad::validate_frequency(frequency)) return;
            if (!tas5805m_biquad::validate_q(q)) return;

            ESP_LOGI("room_cal", "set_notch: ch=%d idx=%d fc=%.1fHz Q=%.2f",
                     channel, index, frequency, q);

            // Array to receive calculated coefficients
            float coeffs[5];

            bool success = tas5805m_biquad::write_notch(
                id(i2c_bus), id(tas5805m_addr),
                channel, index,
                frequency, q,
                48000.0f, coeffs
            );

            if (success) {
                ESP_LOGI("room_cal", "Notch written successfully");

                // Update shadow state with calculated coefficients
                tas5805m_profile::add_filter_to_profile(
                    tas5805m_profile::current_profile_shadow(),
                    channel, index,
                    coeffs[0], coeffs[1], coeffs[2], coeffs[3], coeffs[4]
                );
            } else {
                ESP_LOGE("room_cal", "Failed to write notch");
            }

    # =========================================================================
    # Reset single biquad to bypass
    # =========================================================================
    - service: reset_biquad
      variables:
        channel: int
        index: int
      then:
        - lambda: |-
            // Validate parameters using helper functions
            if (!tas5805m_biquad::validate_channel(channel)) return;
            if (!tas5805m_biquad::validate_index(index)) return;

            ESP_LOGI("room_cal", "reset_biquad: ch=%d idx=%d", channel, index);

            bool success = tas5805m_biquad::reset_biquad(
                id(i2c_bus), id(tas5805m_addr),
                channel, index
            );

            if (success) {
                ESP_LOGI("room_cal", "Biquad %d reset to bypass", index);

                // Update shadow state with bypass coefficients
                tas5805m_profile::add_filter_to_profile(
                    tas5805m_profile::current_profile_shadow(),
                    channel, index,
                    1.0f, 0.0f, 0.0f, 0.0f, 0.0f
                );
            } else {
                ESP_LOGE("room_cal", "Failed to reset biquad %d", index);
            }

    # =========================================================================
    # Reset ALL biquads to bypass (flat response)
    # =========================================================================
    - service: reset_all_biquads
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Resetting all biquads to bypass");

            bool success = tas5805m_biquad::reset_all_biquads(id(i2c_bus), id(tas5805m_addr));

            if (success) {
                ESP_LOGI("room_cal", "All biquads reset to bypass - flat response");
                // Clear shadow state
                tas5805m_profile::current_profile_shadow() = tas5805m_profile::CalibrationProfile();
            } else {
                ESP_LOGE("room_cal", "Failed to reset some biquads");
            }

    # =========================================================================
    # PROFILE MANAGEMENT
    # =========================================================================

    # Save current biquad configuration as a named profile
    - service: save_profile
      variables:
        profile_name: string
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Saving profile: %s", profile_name.c_str());

            bool success = tas5805m_profile::profile_manager().save_profile(
                profile_name,
                tas5805m_profile::current_profile_shadow()
            );

            if (success) {
                ESP_LOGI("room_cal", "Profile '%s' saved successfully", profile_name.c_str());
            } else {
                ESP_LOGE("room_cal", "Failed to save profile '%s'", profile_name.c_str());
            }

    # Load and apply a saved profile
    - service: load_profile
      variables:
        profile_name: string
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Loading profile: %s", profile_name.c_str());

            tas5805m_profile::CalibrationProfile profile;
            if (!tas5805m_profile::profile_manager().load_profile(profile_name, profile)) {
                ESP_LOGE("room_cal", "Failed to load profile '%s'", profile_name.c_str());
                return;
            }

            // Apply all filters
            bool success = true;
            uint8_t addr = id(tas5805m_addr);
            for (int i = 0; i < 15; i++) {
                // Left channel
                auto& lc = profile.left_channel[i];
                if (!tas5805m_biquad::write_biquad(id(i2c_bus), addr, 0, i,
                                                   lc.b0, lc.b1, lc.b2, lc.a1, lc.a2)) {
                    success = false;
                }

                // Right channel
                auto& rc = profile.right_channel[i];
                if (!tas5805m_biquad::write_biquad(id(i2c_bus), addr, 1, i,
                                                   rc.b0, rc.b1, rc.b2, rc.a1, rc.a2)) {
                    success = false;
                }

                delay(2);  // Small delay between writes
            }

            if (success) {
                ESP_LOGI("room_cal", "Profile '%s' loaded and applied", profile_name.c_str());
                // Update shadow state
                tas5805m_profile::current_profile_shadow() = profile;
            } else {
                ESP_LOGE("room_cal", "Errors occurred while applying profile '%s'", profile_name.c_str());
            }

    # Delete a saved profile
    - service: delete_profile
      variables:
        profile_name: string
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Deleting profile: %s", profile_name.c_str());

            bool success = tas5805m_profile::profile_manager().delete_profile(profile_name);

            if (success) {
                ESP_LOGI("room_cal", "Profile '%s' deleted", profile_name.c_str());
            } else {
                ESP_LOGE("room_cal", "Failed to delete profile '%s'", profile_name.c_str());
            }

    # Set a profile as the active profile (loads on boot)
    - service: set_active_profile
      variables:
        profile_name: string
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Setting active profile: %s", profile_name.c_str());

            bool success = tas5805m_profile::profile_manager().set_active_profile(profile_name);

            if (success) {
                ESP_LOGI("room_cal", "Active profile set to '%s'", profile_name.c_str());
            } else {
                ESP_LOGE("room_cal", "Failed to set active profile to '%s'", profile_name.c_str());
            }

    # Clear the active profile (no profile loaded on boot)
    - service: clear_active_profile
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Clearing active profile");

            bool success = tas5805m_profile::profile_manager().set_active_profile(-1);

            if (success) {
                ESP_LOGI("room_cal", "Active profile cleared");
            } else {
                ESP_LOGE("room_cal", "Failed to clear active profile");
            }

    # =========================================================================
    # Calibration mode control (for web UI)
    # =========================================================================
    - service: enter_calibration_mode
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Entering calibration mode");
            id(calibration_active) = true;
            // Note: In a production system, you might want to:
            // - Disable the 15-band graphic EQ temporarily
            // - Save current filter state
            // - Reset filters to flat for measurement

    - service: exit_calibration_mode
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Exiting calibration mode");
            id(calibration_active) = false;
            // Note: In a production system, you might want to:
            // - Re-enable the 15-band graphic EQ
            // - Restore previous filter state if measurement was cancelled

# =============================================================================
# CALIBRATION SCRIPTS
# =============================================================================

script:
  # Play a sine sweep for measurement (state tracking only)
  - id: play_test_sweep
    mode: single
    then:
      - lambda: |-
          id(calibration_active) = true;
          ESP_LOGI("room_cal", "Starting test sweep");
      - delay: 6s
      - lambda: |-
          id(calibration_active) = false;
          ESP_LOGI("room_cal", "Test sweep complete");

  # Apply the active calibration profile (if one is set)
  - id: apply_stored_calibration
    mode: single
    then:
      - lambda: |-
          ESP_LOGI("room_cal", "Applying stored calibration profile");

          // Load and apply the active profile using profile manager
          bool success = tas5805m_profile::profile_manager().load_and_apply_active_profile(
              id(i2c_bus), id(tas5805m_addr)
          );

          if (success) {
              // Also update shadow state from the active profile
              std::string active_name = tas5805m_profile::profile_manager().get_active_profile_name();
              if (active_name != "none" && active_name != "error") {
                  tas5805m_profile::CalibrationProfile profile;
                  if (tas5805m_profile::profile_manager().load_profile(active_name, profile)) {
                      tas5805m_profile::current_profile_shadow() = profile;
                      ESP_LOGI("room_cal", "Shadow state synced with active profile '%s'", active_name.c_str());
                  }
              }
          } else {
              ESP_LOGW("room_cal", "No active profile to apply or load failed");
          }

# =============================================================================
# STATUS SENSORS
# =============================================================================

binary_sensor:
  - platform: template
    name: "Room Calibration Active"
    id: room_cal_active_sensor
    lambda: return id(calibration_active);

text_sensor:
  - platform: template
    name: "Active Calibration Profile"
    id: active_cal_profile
    update_interval: 10s
    lambda: |-
      return tas5805m_profile::profile_manager().get_active_profile_name();

  - platform: template
    name: "Available Profiles"
    id: available_profiles
    update_interval: 30s
    lambda: |-
      auto profiles = tas5805m_profile::profile_manager().list_profiles();
      if (profiles.empty()) {
        return std::string("none");
      }

      std::string result = "";
      for (size_t i = 0; i < profiles.size(); i++) {
        if (i > 0) result += ", ";
        result += profiles[i];
      }
      return result;
