# =============================================================================
# ROOM CORRECTION SERVICES FOR LOUDER-ESP32S3
# =============================================================================
# Include this in your main config with:
#   packages:
#     room_correction: !include room_correction_services.yaml
#
# Or copy the relevant sections into your main YAML.
#
# Requires:
#   - i2c bus with id: i2c_bus
#   - tas5805m_biquad_i2c.h in the same directory
# =============================================================================

esphome:
  includes:
    - tas5805m_biquad_i2c.h
    - tas5805m_profile_manager.h
  on_boot:
    priority: -100  # Run after other components initialize
    then:
      - lambda: |-
          // Initialize profile manager and load active profile
          id(profile_manager).setup();

          // Auto-load active profile if one is set
          id(profile_manager).load_and_apply_active_profile(id(i2c_bus), 0x2C);

# Enable web server for calibration UI
web_server:
  port: 80
  version: 3
  local: true

# Globals for calibration state
globals:
  - id: calibration_active
    type: bool
    initial_value: 'false'

  - id: test_tone_frequency
    type: float
    initial_value: '1000.0'

  # Shadow state for current biquad configuration
  # Used to capture current state when saving profiles
  - id: current_profile_shadow
    type: tas5805m_profile::CalibrationProfile
    restore_value: no

  # Global profile manager instance
  - id: profile_manager
    type: tas5805m_profile::ProfileManager
    restore_value: no

# =============================================================================
# HOME ASSISTANT SERVICES
# =============================================================================

api:
  services:
    # =========================================================================
    # Raw biquad programming (for advanced users)
    # =========================================================================
    - service: set_biquad
      variables:
        channel: int      # 0 = left, 1 = right, 2 = both
        index: int        # 0-14 (which of the 15 biquads)
        b0: float
        b1: float
        b2: float
        a1: float
        a2: float
      then:
        - lambda: |-
            // Validate parameters
            if (channel < 0 || channel > 2) {
                ESP_LOGE("room_cal", "Invalid channel: %d (must be 0-2)", channel);
                return;
            }
            if (index < 0 || index >= 15) {
                ESP_LOGE("room_cal", "Invalid biquad index: %d (must be 0-14)", index);
                return;
            }
            if (!std::isfinite(b0) || !std::isfinite(b1) || !std::isfinite(b2) ||
                !std::isfinite(a1) || !std::isfinite(a2)) {
                ESP_LOGE("room_cal", "Coefficient contains NaN or Inf");
                return;
            }

            ESP_LOGI("room_cal", "set_biquad: ch=%d idx=%d", channel, index);
            ESP_LOGI("room_cal", "  b0=%.6f b1=%.6f b2=%.6f a1=%.6f a2=%.6f", b0, b1, b2, a1, a2);

            bool success = tas5805m_biquad::write_biquad(
                id(i2c_bus), 0x2C,
                channel, index,
                b0, b1, b2, a1, a2
            );

            if (success) {
                ESP_LOGI("room_cal", "Biquad %d written successfully", index);

                // Update shadow state
                tas5805m_profile::add_filter_to_profile(
                    id(current_profile_shadow),
                    channel, index,
                    b0, b1, b2, a1, a2
                );
            } else {
                ESP_LOGE("room_cal", "Failed to write biquad %d", index);
            }

    # =========================================================================
    # Parametric EQ (most common for room correction)
    # =========================================================================
    - service: set_parametric_eq
      variables:
        channel: int      # 0 = left, 1 = right, 2 = both
        index: int        # 0-14
        frequency: float  # Center frequency in Hz (20-20000)
        gain_db: float    # Gain in dB (-15 to +6 recommended)
        q: float          # Q factor (0.5 to 10)
      then:
        - lambda: |-
            // Validate parameters
            if (channel < 0 || channel > 2) {
                ESP_LOGE("room_cal", "Invalid channel: %d (must be 0-2)", channel);
                return;
            }
            if (index < 0 || index >= 15) {
                ESP_LOGE("room_cal", "Invalid biquad index: %d (must be 0-14)", index);
                return;
            }
            if (frequency < 10 || frequency > 24000) {
                ESP_LOGE("room_cal", "Invalid frequency: %.1f (must be 10-24000 Hz)", frequency);
                return;
            }
            if (!std::isfinite(gain_db) || gain_db < -20 || gain_db > 20) {
                ESP_LOGE("room_cal", "Invalid gain: %.1f (must be -20 to +20 dB)", gain_db);
                return;
            }
            if (q < 0.1 || q > 20) {
                ESP_LOGE("room_cal", "Invalid Q: %.2f (must be 0.1-20)", q);
                return;
            }

            ESP_LOGI("room_cal", "set_parametric_eq: ch=%d idx=%d fc=%.1fHz gain=%.1fdB Q=%.2f",
                     channel, index, frequency, gain_db, q);

            // Calculate coefficients for shadow state (using same formula as C++ code)
            const float fs = 48000.0f;
            const float A = std::pow(10.0f, gain_db / 40.0f);
            const float omega = 2.0f * M_PI * frequency / fs;
            const float sin_omega = std::sin(omega);
            const float cos_omega = std::cos(omega);
            const float alpha = sin_omega / (2.0f * q);

            float b0 = 1.0f + alpha * A;
            float b1 = -2.0f * cos_omega;
            float b2 = 1.0f - alpha * A;
            float a0 = 1.0f + alpha / A;
            float a1 = -2.0f * cos_omega;
            float a2 = 1.0f - alpha / A;

            // Normalize by a0
            b0 /= a0; b1 /= a0; b2 /= a0; a1 /= a0; a2 /= a0;

            bool success = tas5805m_biquad::write_parametric_eq(
                id(i2c_bus), 0x2C,
                channel, index,
                frequency, gain_db, q
            );

            if (success) {
                ESP_LOGI("room_cal", "Parametric EQ written successfully");

                // Update shadow state with calculated coefficients
                tas5805m_profile::add_filter_to_profile(
                    id(current_profile_shadow),
                    channel, index,
                    b0, b1, b2, a1, a2
                );
            } else {
                ESP_LOGE("room_cal", "Failed to write parametric EQ");
            }

    # =========================================================================
    # Low shelf filter (bass adjustment)
    # =========================================================================
    - service: set_low_shelf
      variables:
        channel: int
        index: int
        frequency: float  # Corner frequency in Hz
        gain_db: float    # Gain in dB
        slope: float      # Slope (0.5 to 2.0, 1.0 = 6dB/oct)
      then:
        - lambda: |-
            // Validate parameters
            if (channel < 0 || channel > 2) {
                ESP_LOGE("room_cal", "Invalid channel: %d", channel);
                return;
            }
            if (index < 0 || index >= 15) {
                ESP_LOGE("room_cal", "Invalid index: %d", index);
                return;
            }
            if (frequency < 10 || frequency > 24000) {
                ESP_LOGE("room_cal", "Invalid frequency: %.1f", frequency);
                return;
            }
            if (!std::isfinite(gain_db) || gain_db < -20 || gain_db > 20) {
                ESP_LOGE("room_cal", "Invalid gain: %.1f", gain_db);
                return;
            }
            if (slope < 0.1 || slope > 5.0) {
                ESP_LOGE("room_cal", "Invalid slope: %.2f", slope);
                return;
            }

            ESP_LOGI("room_cal", "set_low_shelf: ch=%d idx=%d fc=%.1fHz gain=%.1fdB slope=%.2f",
                     channel, index, frequency, gain_db, slope);

            bool success = tas5805m_biquad::write_low_shelf(
                id(i2c_bus), 0x2C,
                channel, index,
                frequency, gain_db, slope
            );

            if (success) {
                ESP_LOGI("room_cal", "Low shelf written successfully");
            } else {
                ESP_LOGE("room_cal", "Failed to write low shelf");
            }

    # =========================================================================
    # High shelf filter (treble adjustment)
    # =========================================================================
    - service: set_high_shelf
      variables:
        channel: int
        index: int
        frequency: float
        gain_db: float
        slope: float
      then:
        - lambda: |-
            // Validate parameters
            if (channel < 0 || channel > 2) {
                ESP_LOGE("room_cal", "Invalid channel: %d", channel);
                return;
            }
            if (index < 0 || index >= 15) {
                ESP_LOGE("room_cal", "Invalid index: %d", index);
                return;
            }
            if (frequency < 10 || frequency > 24000) {
                ESP_LOGE("room_cal", "Invalid frequency: %.1f", frequency);
                return;
            }
            if (!std::isfinite(gain_db) || gain_db < -20 || gain_db > 20) {
                ESP_LOGE("room_cal", "Invalid gain: %.1f", gain_db);
                return;
            }
            if (slope < 0.1 || slope > 5.0) {
                ESP_LOGE("room_cal", "Invalid slope: %.2f", slope);
                return;
            }

            ESP_LOGI("room_cal", "set_high_shelf: ch=%d idx=%d fc=%.1fHz gain=%.1fdB slope=%.2f",
                     channel, index, frequency, gain_db, slope);

            bool success = tas5805m_biquad::write_high_shelf(
                id(i2c_bus), 0x2C,
                channel, index,
                frequency, gain_db, slope
            );

            if (success) {
                ESP_LOGI("room_cal", "High shelf written successfully");
            } else {
                ESP_LOGE("room_cal", "Failed to write high shelf");
            }

    # =========================================================================
    # High-pass filter (subsonic protection)
    # =========================================================================
    - service: set_highpass
      variables:
        channel: int
        index: int
        frequency: float  # Cutoff frequency in Hz
        q: float          # Q factor (0.707 = Butterworth)
      then:
        - lambda: |-
            // Validate parameters
            if (channel < 0 || channel > 2) {
                ESP_LOGE("room_cal", "Invalid channel: %d", channel);
                return;
            }
            if (index < 0 || index >= 15) {
                ESP_LOGE("room_cal", "Invalid index: %d", index);
                return;
            }
            if (frequency < 5 || frequency > 24000) {
                ESP_LOGE("room_cal", "Invalid frequency: %.1f", frequency);
                return;
            }
            if (q < 0.1 || q > 20) {
                ESP_LOGE("room_cal", "Invalid Q: %.2f", q);
                return;
            }

            ESP_LOGI("room_cal", "set_highpass: ch=%d idx=%d fc=%.1fHz Q=%.2f",
                     channel, index, frequency, q);

            bool success = tas5805m_biquad::write_highpass(
                id(i2c_bus), 0x2C,
                channel, index,
                frequency, q
            );

            if (success) {
                ESP_LOGI("room_cal", "High-pass written successfully");
            } else {
                ESP_LOGE("room_cal", "Failed to write high-pass");
            }

    # =========================================================================
    # Low-pass filter (tweeter protection)
    # =========================================================================
    - service: set_lowpass
      variables:
        channel: int
        index: int
        frequency: float
        q: float
      then:
        - lambda: |-
            // Validate parameters
            if (channel < 0 || channel > 2) {
                ESP_LOGE("room_cal", "Invalid channel: %d", channel);
                return;
            }
            if (index < 0 || index >= 15) {
                ESP_LOGE("room_cal", "Invalid index: %d", index);
                return;
            }
            if (frequency < 10 || frequency > 24000) {
                ESP_LOGE("room_cal", "Invalid frequency: %.1f", frequency);
                return;
            }
            if (q < 0.1 || q > 20) {
                ESP_LOGE("room_cal", "Invalid Q: %.2f", q);
                return;
            }

            ESP_LOGI("room_cal", "set_lowpass: ch=%d idx=%d fc=%.1fHz Q=%.2f",
                     channel, index, frequency, q);

            bool success = tas5805m_biquad::write_lowpass(
                id(i2c_bus), 0x2C,
                channel, index,
                frequency, q
            );

            if (success) {
                ESP_LOGI("room_cal", "Low-pass written successfully");
            } else {
                ESP_LOGE("room_cal", "Failed to write low-pass");
            }

    # =========================================================================
    # Notch filter (kill specific resonance)
    # =========================================================================
    - service: set_notch
      variables:
        channel: int
        index: int
        frequency: float
        q: float
      then:
        - lambda: |-
            // Validate parameters
            if (channel < 0 || channel > 2) {
                ESP_LOGE("room_cal", "Invalid channel: %d", channel);
                return;
            }
            if (index < 0 || index >= 15) {
                ESP_LOGE("room_cal", "Invalid index: %d", index);
                return;
            }
            if (frequency < 10 || frequency > 24000) {
                ESP_LOGE("room_cal", "Invalid frequency: %.1f", frequency);
                return;
            }
            if (q < 0.1 || q > 20) {
                ESP_LOGE("room_cal", "Invalid Q: %.2f", q);
                return;
            }

            ESP_LOGI("room_cal", "set_notch: ch=%d idx=%d fc=%.1fHz Q=%.2f",
                     channel, index, frequency, q);

            bool success = tas5805m_biquad::write_notch(
                id(i2c_bus), 0x2C,
                channel, index,
                frequency, q
            );

            if (success) {
                ESP_LOGI("room_cal", "Notch written successfully");
            } else {
                ESP_LOGE("room_cal", "Failed to write notch");
            }

    # =========================================================================
    # Reset single biquad to bypass
    # =========================================================================
    - service: reset_biquad
      variables:
        channel: int
        index: int
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "reset_biquad: ch=%d idx=%d", channel, index);

            bool success = tas5805m_biquad::reset_biquad(
                id(i2c_bus), 0x2C,
                channel, index
            );

            if (success) {
                ESP_LOGI("room_cal", "Biquad %d reset to bypass", index);
            } else {
                ESP_LOGE("room_cal", "Failed to reset biquad %d", index);
            }

    # =========================================================================
    # Reset ALL biquads to bypass (flat response)
    # =========================================================================
    - service: reset_all_biquads
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Resetting all biquads to bypass");

            bool success = tas5805m_biquad::reset_all_biquads(id(i2c_bus), 0x2C);

            if (success) {
                ESP_LOGI("room_cal", "All biquads reset to bypass - flat response");
                // Clear shadow state
                id(current_profile_shadow) = tas5805m_profile::CalibrationProfile();
            } else {
                ESP_LOGE("room_cal", "Failed to reset some biquads");
            }

    # =========================================================================
    # PROFILE MANAGEMENT
    # =========================================================================

    # Save current biquad configuration as a named profile
    - service: save_profile
      variables:
        profile_name: string
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Saving profile: %s", profile_name.c_str());

            bool success = id(profile_manager).save_profile(
                profile_name,
                id(current_profile_shadow)
            );

            if (success) {
                ESP_LOGI("room_cal", "Profile '%s' saved successfully", profile_name.c_str());
            } else {
                ESP_LOGE("room_cal", "Failed to save profile '%s'", profile_name.c_str());
            }

    # Load and apply a saved profile
    - service: load_profile
      variables:
        profile_name: string
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Loading profile: %s", profile_name.c_str());

            tas5805m_profile::CalibrationProfile profile;
            if (!id(profile_manager).load_profile(profile_name, profile)) {
                ESP_LOGE("room_cal", "Failed to load profile '%s'", profile_name.c_str());
                return;
            }

            // Apply all filters
            bool success = true;
            for (int i = 0; i < 15; i++) {
                // Left channel
                auto& lc = profile.left_channel[i];
                if (!tas5805m_biquad::write_biquad(id(i2c_bus), 0x2C, 0, i,
                                                   lc.b0, lc.b1, lc.b2, lc.a1, lc.a2)) {
                    success = false;
                }

                // Right channel
                auto& rc = profile.right_channel[i];
                if (!tas5805m_biquad::write_biquad(id(i2c_bus), 0x2C, 1, i,
                                                   rc.b0, rc.b1, rc.b2, rc.a1, rc.a2)) {
                    success = false;
                }

                delay(2);  // Small delay between writes
            }

            if (success) {
                ESP_LOGI("room_cal", "Profile '%s' loaded and applied", profile_name.c_str());
                // Update shadow state
                id(current_profile_shadow) = profile;
            } else {
                ESP_LOGE("room_cal", "Errors occurred while applying profile '%s'", profile_name.c_str());
            }

    # Delete a saved profile
    - service: delete_profile
      variables:
        profile_name: string
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Deleting profile: %s", profile_name.c_str());

            bool success = id(profile_manager).delete_profile(profile_name);

            if (success) {
                ESP_LOGI("room_cal", "Profile '%s' deleted", profile_name.c_str());
            } else {
                ESP_LOGE("room_cal", "Failed to delete profile '%s'", profile_name.c_str());
            }

    # Set a profile as the active profile (loads on boot)
    - service: set_active_profile
      variables:
        profile_name: string
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Setting active profile: %s", profile_name.c_str());

            bool success = id(profile_manager).set_active_profile(profile_name);

            if (success) {
                ESP_LOGI("room_cal", "Active profile set to '%s'", profile_name.c_str());
            } else {
                ESP_LOGE("room_cal", "Failed to set active profile to '%s'", profile_name.c_str());
            }

    # Clear the active profile (no profile loaded on boot)
    - service: clear_active_profile
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Clearing active profile");

            bool success = id(profile_manager).set_active_profile(-1);

            if (success) {
                ESP_LOGI("room_cal", "Active profile cleared");
            } else {
                ESP_LOGE("room_cal", "Failed to clear active profile");
            }

    # =========================================================================
    # Calibration mode control (for web UI)
    # =========================================================================
    - service: enter_calibration_mode
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Entering calibration mode");
            id(calibration_active) = true;
            // Note: In a production system, you might want to:
            // - Disable the 15-band graphic EQ temporarily
            // - Save current filter state
            // - Reset filters to flat for measurement

    - service: exit_calibration_mode
      then:
        - lambda: |-
            ESP_LOGI("room_cal", "Exiting calibration mode");
            id(calibration_active) = false;
            // Note: In a production system, you might want to:
            // - Re-enable the 15-band graphic EQ
            // - Restore previous filter state if measurement was cancelled

# =============================================================================
# CALIBRATION SCRIPTS
# =============================================================================

script:
  # Play a sine sweep for measurement (state tracking only)
  - id: play_test_sweep
    mode: single
    then:
      - lambda: |-
          id(calibration_active) = true;
          ESP_LOGI("room_cal", "Starting test sweep");
      - delay: 6s
      - lambda: |-
          id(calibration_active) = false;
          ESP_LOGI("room_cal", "Test sweep complete");

  # Apply a stored calibration profile
  - id: apply_stored_calibration
    mode: single
    then:
      - lambda: |-
          // TODO: Load from NVS and apply
          ESP_LOGI("room_cal", "Applying stored calibration profile");

# =============================================================================
# STATUS SENSORS
# =============================================================================

binary_sensor:
  - platform: template
    name: "Room Calibration Active"
    id: room_cal_active_sensor
    lambda: return id(calibration_active);

text_sensor:
  - platform: template
    name: "Active Calibration Profile"
    id: active_cal_profile
    update_interval: 10s
    lambda: |-
      return id(profile_manager).get_active_profile_name();

  - platform: template
    name: "Available Profiles"
    id: available_profiles
    update_interval: 30s
    lambda: |-
      auto profiles = id(profile_manager).list_profiles();
      if (profiles.empty()) {
        return std::string("none");
      }

      std::string result = "";
      for (size_t i = 0; i < profiles.size(); i++) {
        if (i > 0) result += ", ";
        result += profiles[i];
      }
      return result;
